---
title: "VarDecomp"
output: html_document
editor_options: 
  chunk_output_type: console
  
---
```{r development, include=FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
library(ggplot2)
```


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)

```


```{r development-inflate, eval=FALSE}
# Execute in the console directly - keep eval=TRUE to avoid infinite loop
fusen::inflate(flat_file = "dev/VarDecomp_package.Rmd", vignette_name = "vignette")
```

# brms_model

```{r function-brms_model}

#' Run a brms model
#'
#' @param Data A data frame containing the data - covariates should be centered to a the mean or to a meaningful zero (see Schielzeth H. 2010. Simple means to improve the interpretability of regression coefficients. Methods Ecol Evol. 1:103–113. doi:10.1111/j.2041-210X.2010.00012.x.).
#' @param Response String with the name of the column in Data containing the response variable (e.g. "mass"). 
#' @param FixedEffect String with the name of the column in Data containing the fixed effect variable (e.g. "height"). To add multiple fixed effects, use c() (e.g. c("height", "sex")). 
#' @param RandomEffect String with the name of the column in Data containing the random effect variable (e.g. "species"). The current package version allows the use of a single random effect.
#' @param RandomSlope Vector containing two values: first a string with the name of the column in Data containing the covariate to be added as a random slope, second the random effect to which the  random slope will be applied (e.g. RandomSlope = c("height", "species")). The current package version allows the use of a single random slope.
#' @param Chainset Defines the number of iterations. Start with Chainset = 1 and increase as needed until convergence. The value of Chainsetis multiplied by 15000 in warmup, 30000 in iterations and 15 in thin intervale. For quick tests use Chainset = 0 (warmup=10; iter=110; thin=10; chains=2) 
#' @param Family String to define the family function in the brms model. Current supported families: "gaussian", "binomial", "poisson".
#' @param Seed Numeric and optional. Set a seed in order to repeat the results from the model when running it more than once. 
#' @param Trials The total number of trials in a binomial model. The number of successes should be imputed on Response.
#' @param PriorSamples Logical value that defines if brmsfit will contain the priors used. Default is set to `FALSE`, which does not includ the priors in the brmsfit. 
#'
#' @return Returns a brmsfit
#' @import BH
#' @import brms
#' @import rstan
#' @import RcppEigen
#' @export 
#'

brms_model = function(Data, Response, FixedEffect, RandomEffect = NULL, RandomSlope = NULL, 
  Chainset = 1, Family = "gaussian", Seed = NULL, Trials = NA, PriorSamples = TRUE) {

stopifnot("`Data` must be a data frame" = inherits(Data, "data.frame"))
  
stopifnot("`Response` must be a string" = inherits(Response, "character"))

if(Family == "binomial"){
  Successes = Data[[Response]]
  stopifnot("Family 'binomial' requires an integer response variable." =inherits(Successes, "integer"))
}

if(Family == "binomial"){
  Attempts = Data[[Trials]]
  stopifnot("Family 'binomial' requires an integer trial variable." =inherits(Attempts, "integer"))
}

if(Family == "poisson"){
  Resp = Data[[Response]]
  stopifnot("Family 'poisson' requires an integer response variable." =inherits(Resp, "integer"))
}

stopifnot("`FixedEffect` must be a string" = inherits(FixedEffect, "character"))

if(!is.null(RandomEffect)) {
  stopifnot("`RandomEffect` must be a string" = inherits(RandomEffect, "character"))
}

if(!is.null(RandomSlope)){
  stopifnot(
  "`RandomSlope` must be a vector containing two string values" =
  inherits(RandomSlope, "character"),
  
  "`RandomSlope` must contain two values (e.g. RandomSlope = c('covariate name', 
  'random effect')" = length(RandomSlope) == 2)
}

stopifnot("`Chainset` must be a numeric value" = inherits(Chainset, "numeric"))

stopifnot("`Family` must be a string" = inherits(Family, "character"))

if(Family == "binomial" && is.na(Trials)){
  stop("Binomial models require the total number of trials (use `Trial =` for inputing 
  the corresponding variable) and a response variable with the number of successes (use 
  `Response =` for inputing the variable with the count of successes).")
}

if(is.null(Seed)){
 Seed = sample(1000:9999, 1)

} else {
  if(!is.null(Seed)){
  stopifnot("`Seed` must be numeric" = inherits(Seed, "numeric"))
  } 
}

stopifnot("`PriorSamples` must be logical" = inherits(PriorSamples, "logical"))


testfunction = function(){
  emojis = c("\U1F600", "\U1F604", "\U1F601", "\U1F643", "\U1F609", "\U1F60A", "\U1F929", 
  "\U1F917", "\U1F92D", "\U1F973", "\U1F920", "\U1F978", "\U1F60E", "\U1F913", "\U1F47D", 
  "\U1F638", "\U1F596", "\U1F44C", "\U270C", "\U1F44D", "\U1F44F", "\U1F64C", "\U1F40C", 
  "\U1F41B", "\U1F41E", "\U1F997")  
  
  print(paste("No problems so far", sample(emojis, size = 1)))
}

testfunction()
  
# Setting chains 
if(Chainset ==0){
  Warmup=10; Iter=110; Thin=10; Chains=2

} else {
  Warmup=15000*Chainset
  Iter=30000*Chainset
  Thin=15*Chainset
  Chains=2
}

# Add an observation ID for models of binomial or poisson families
if(Family == "binomial" | Family == "poisson"){
  Data = Data %>%
  dplyr::mutate(observationID = as.factor(dplyr::row_number(Data)))
}

# Construct model formula if binomial family 
if(Family == "binomial"){
  bfform = 
    
    if(is.null(RandomEffect)) {
      
      if(is.null(RandomSlope)){
        paste0(Response, " | trials(", Trials, ") ~ ", 
        paste(FixedEffect, collapse = " + "), " + (1|observationID)")
        
      } else {
        
      if(!is.null(RandomSlope)) {
        paste0(Response, " | trials(", Trials, ") ~ ", paste(FixedEffect, collapse = " + "), 
        " + (1 + ", RandomSlope[1], " |", RandomSlope[2], ") + (1|observationID)")
      }
      }

    } else {
    
    if(!is.null(RandomEffect)) {
        
      if(is.null(RandomSlope)){
        paste0(Response, " | trials(", Trials, ") ~ ", paste(FixedEffect, collapse = " + "),
        " + ", paste("(1|", RandomEffect, ")", sep = "", collapse = " + "), " + (1|observationID)")
       
      } else {
        
      if(!is.null(RandomSlope)){ 
          paste0(Response, " | trials(", Trials, ") ~ ", paste(FixedEffect, collapse = " + "),
          " + (1 + ", RandomSlope[1], " |", RandomSlope[2],") + ", 
          paste("(1|", RandomEffect, ")", sep = "", collapse = " + ")," + (1|observationID)")
        }
      }
    }
    } 
  
} else {

# Construct the formula object if poisson family
  
if(Family == "poisson"){
  bfform = 
    
    if(is.null(RandomEffect)) {
      
      if(is.null(RandomSlope)){
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), " + (1|observationID)")
      
      } else {
        
      if(!is.null(RandomSlope)){
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "),
        " + (1 + ", RandomSlope[1], " |", RandomSlope[2], ") + (1|observationID)")
        }
      }
    
    } else {
    
    if(!is.null(RandomEffect)) {  
      
      if(is.null(RandomSlope)){
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), " + ",
        paste("(1|", RandomEffect, ")", sep = "", collapse = " + "), " + (1|observationID)")

      } else {
      
      if(!is.null(RandomSlope)){    
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), 
        " + (1 + ", RandomSlope[1], " |", RandomSlope[2],") + ", 
        paste("(1|", RandomEffect, ")", sep = "", collapse = " + "), " + (1|observationID)")}
      }
    }
    }

} else {

# Construct the formula object for other model families
  bfform = 
    
    if(is.null(RandomEffect)) {
      
      if(is.null(RandomSlope)){
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "))
      
      } else {
      
      if(!is.null(RandomSlope)){
        paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "),
        " + (1 + ", RandomSlope[1], " |", RandomSlope[2], ")")
      }
      }
    } else {

      if(!is.null(RandomEffect)) {
        
        if(is.null(RandomSlope)){
          paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), " + ", 
          paste("(1|", RandomEffect, ")", sep = "", collapse = " + "))

        } else {
        
        if(!is.null(RandomSlope)){
            paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "),
            " + (1 + ", RandomSlope[1], " |", RandomSlope[2],") + ",
            paste("(1|", RandomEffect, ")", sep = "", collapse = " + "))
        }
        }
      }
    }
  }
}

mod =  brms::brm(brms::bf(stats::as.formula(bfform)),
                family = Family,
                data = Data, 
                warmup = Warmup,
                iter = Iter, 
                thin=Thin, 
                chains = Chains, 
                init = "random", 
                seed = Seed, 
                cores = parallel::detectCores(), 
                control = list(adapt_delta = 0.999), 
                sample_prior = PriorSamples)

brmsfit = mod

if(max(tidybayes::summarise_draws(mod)$rhat) > 1.1){
  warning("Model did not converge. Try increasing the value of `Chainset`.")
}

return(brmsfit)

}


```

```{r examples-brms_model, eval=FALSE}
#' \dontrun{

md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod = brms_model(Chainset = 2, 
           Response = "mass", 
           FixedEffect = c("sex","height"),
           RandomSlope = c("height", "species"),
           Family = "gaussian", 
           Data = md, 
           Seed = 0405)

#' }

```

```{r test-brms_model}

#included below as functions

```

# mod
```{r dev-mod, eval=TRUE}
library(tidyverse)
md = dplyr::starwars


# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))


mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = c("sex","height"), 
                 Family = "gaussian", 
                 Data = md)

save(mod, file = "data/mod.RData")
```

```{r function-mod}
#' Example model with fixed effects only
#' @format A `brmsfit` object.
#' @source Generated using the `brms_model` function.

"mod"
```

```{r examples-mod}

mod = data("mod", package = "VarDecomp")

```


# mod_RE
```{r dev-mod_RE, eval=TRUE}
md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))


# With random effect
mod_RE = brms_model(Chainset = 2,
                     Response = "mass", 
                     FixedEffect = c("sex","height"), 
                     RandomEffect = "species", 
                     Family = "gaussian", 
                     Data = md)

save(mod_RE, file = "data/mod_RE.RData")

```

```{r function-mod_RE}
#' Example model with fixed and random effects
#' @format A `brmsfit` object.
#' @source Generated using the `brms_model` function.

"mod_RE"

```

```{r examples-mod_RE}

mod = data("mod_RE", package = "VarDecomp")

```


# mod_RS
```{r dev-mod_RS, eval=TRUE}
md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))


# With random slope
mod_RS = brms_model(Chainset = 3,
                     Response = "mass", 
                     FixedEffect = c("sex","height"),
                     RandomSlope = c("height", "species"),
                     Family = "gaussian", 
                     Data = md)

save(mod_RS, file = "data/mod_RS.RData")

```

```{r function-mod_RS}
#' Example model with fixed effects and random slopes
#' @format A `brmsfit` object.
#' @source Generated using the `brms_model` function.

"mod_RS"
```

```{r examples-mod_RS}

mod = data("mod_RS", package = "VarDecomp")

```

______

# brms_cov_model

```{r function-brms_cov_model}

#' Run a brms model containing a covariance matrix
#'
#' @param Data A data frame containing the data - covariates should be centered to a the mean or to a meaningful zero (see Schielzeth H. 2010. Simple means to improve the interpretability of regression coefficients. Methods Ecol Evol. 1:103–113. doi:10.1111/j.2041-210X.2010.00012.x.).
#' @param Response String with the name of the column in Data containing the response variable (e.g. "mass"). 
#' @param FixedEffect String with the name of the column in Data containing the fixed effect variable (e.g. "height"). To add multiple fixed effects, use c() (e.g. c("height", "sex")). 
#' @param RandomEffect String with the name of the column in Data containing the random effect variable (e.g. "species"). To add multiple random effects, use c() (e.g. c("species", "date")). 
#' @param ID String with the name of the column in Data containing the ID of correlated individuals/groups. The current package version allows the use of a single random effect, so no additional random effects are possible yet. 
#' @param Matrix A matrix containing the IDs as row/column names and covariance values (ex. A pedigree relatedness matrix). 
#' @param Chainset Defines the number of iterations. Start with Chainset = 1 and increase as needed until convergence. The value of Chainsetis multiplied by 15000 in warmup, 30000 in iterations and 15 in thin intervale. For quick tests use Chainset = 0 (warmup=10; iter=110; thin=10; chains=2) 
#' @param Family String to define the family function in the brms model. Current supported families: "gaussian", "binomial", "poisson".
#' @param Seed Numeric and optional. Set a seed in order to repeat the results from the model when running it more than once. 
#' @param Trials The total number of trials in a binomial model. The number of successes should be imputed on Response.
#' @param PriorSamples Logical value that defines if brmsfit will contain the priors used. Default is set to `FALSE`, which does not includ the priors in the brmsfit. 
#'
#' @return Returns a brmsfit
#' @import BH
#' @import brms
#' @import rstan
#' @import RcppEigen
#' @export 
#'

brms_cov_model = function(Data, Response, FixedEffect, ID, RandomEffect = NULL, Matrix, Chainset = 1, Family = "gaussian", Seed = NULL, Trials = NA, PriorSamples = TRUE){

stopifnot("`Data` must be a data frame" = inherits(Data, "data.frame"))
  
stopifnot("`Response` must be a string" = inherits(Response, "character"))

if(Family == "binomial"){
  Successes = Data[[Response]]
  stopifnot("Family 'binomial' requires an integer response variable." =inherits(Successes, "integer"))
}

if(Family == "binomial"){
  Attempts = Data[[Trials]]
  stopifnot("Family 'binomial' requires an integer trial variable." =inherits(Attempts, "integer"))
}

if(Family == "poisson"){
  Resp = Data[[Response]]
  stopifnot("Family 'poisson' requires an integer response variable." =inherits(Resp, "integer"))
}

stopifnot("`FixedEffect` must be a string" = inherits(FixedEffect, "character"))

stopifnot("`ID` must be a string" = inherits(ID, "character"))


if(!is.null(RandomEffect)){
  stopifnot("`RandomEffect` must be a string" = inherits(RandomEffect, "character"))
}

if(!is.null(Matrix)){
  stopifnot("`Matrix` must be a matrix" = inherits(Matrix, "matrix"))
}

stopifnot("`Chainset` must be a numeric value" = inherits(Chainset, "numeric"))

stopifnot("`Family` must be a string" = inherits(Family, "character"))

if(Family == "binomial" && is.na(Trials)){
  stop("Binomial models require the total number of trials (use `Trial =` for inputing 
  the corresponding variable) and a response variable with the number of successes (use 
  `Response =` for inputing the variable with the count of successes).")
}

if(is.null(Seed)){
  Seed = sample(1000:9999, 1)

} else {
  if(!is.null(Seed)){
  stopifnot("`Seed` must be numeric" = inherits(Seed, "numeric"))
  }
}

stopifnot("`PriorSamples` must be logical" = inherits(PriorSamples, "logical"))

testfunction = function(){
  emojis = c("\U1F600", "\U1F604", "\U1F601", "\U1F643", "\U1F609", "\U1F60A", "\U1F929", 
  "\U1F917", "\U1F92D", "\U1F973", "\U1F920", "\U1F978", "\U1F60E", "\U1F913", "\U1F47D", 
  "\U1F638", "\U1F596", "\U1F44C", "\U270C", "\U1F44D", "\U1F44F", "\U1F64C", "\U1F40C", 
  "\U1F41B", "\U1F41E", "\U1F997")  
  
  print(paste("No problems so far", sample(emojis, size = 1)))
}

testfunction()
  
# Setting chains 
if(Chainset ==0){
  Warmup=10; Iter=110; Thin=10; Chains=2

} else {
  Warmup=15000*Chainset
  Iter=30000*Chainset
  Thin=15*Chainset
  Chains=2
}

# Add an observation ID for models of binomial or poisson families
if(Family == "binomial" | Family == "poisson"){
  Data = Data %>%
  dplyr::mutate(observationID = as.factor(dplyr::row_number(Data)))
}

# Construct model formula if binomial family 
if(Family == "binomial"){
  bfform = 
  
  if(is.null(RandomEffect)){
    paste0(Response, " | trials(", Trials, ") ~ ", paste(FixedEffect, collapse = " + "),
    " + (1|gr(", ID,", cov = A)) + (1|observationID)")
  
  } else {
  
  if(!is.null(RandomEffect)){
    paste0(Response, " | trials(", Trials, ") ~ ", paste(FixedEffect, collapse = " + "),
    " + (1|gr(", ID,", cov = A)) + ", paste("(1|", RandomEffect, ")", sep = "", collapse = " + "),
    " + (1|observationID)")
  }
  }
} else {

# Construct the formula object if poisson family
  
if(Family == "poisson"){
  bfform =  

  if(is.null(RandomEffect)){
    paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), 
    " + (1|gr(", ID,", cov = A)) + (1|observationID)")
  
  } else {
  if(!is.null(RandomEffect)){
    paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), " + (1|gr(", ID,", cov = A)) + ", 
    paste("(1|", RandomEffect, ")", sep = "", collapse = " + "), " + (1|observationID)")
  }
  }

} else {
  
# Construct the formula object for other model families
bfform = 

  if(is.null(RandomEffect)){
    paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "),
    " + (1|gr(", ID,", cov = A))")

  } else{
  
    if(!is.null(RandomEffect)){
      paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), 
      " + (1|gr(", ID,", cov = A)) + ", 
      paste("(1|", RandomEffect, ")", sep = "", collapse = " + "))
    }
}
}
}


mod =  brms::brm(brms::bf(stats::as.formula(bfform)),
                family = Family,
                data = Data, 
                data2 = list(A = Matrix),
                warmup = Warmup,
                iter = Iter, 
                thin=Thin, 
                chains = Chains, 
                init = "random", 
                seed = Seed, 
                cores = parallel::detectCores(), 
                control = list(adapt_delta = 0.999), 
                sample_prior = PriorSamples)

brmsfit = mod

if(max(tidybayes::summarise_draws(mod)$rhat) > 1.1){
warning("Model did not converge. Try increasing the value of `Chainset`.")}

return(brmsfit)

}

```


```{r examples-brms_cov_model, eval=FALSE}
#' \dontrun{

 library(tidyverse)
 
# Create a group (ID) variable
md = tibble::tibble(
  ID = as.factor(rep(1:10, each = 100))) %>% 

# Create a variables 
  dplyr::mutate(height = rnorm(1000, mean = 170, sd = 10),
         mass = 5 + 0.5 * height + rnorm(1000, mean = 0, sd = 5)) %>% 
  dplyr::mutate(height = height - mean(height))

# Create a covariance matrix (e.g., relatedness matrix)
cov_matrix = matrix(rnorm(10 * 10), 10, 10)
cov_matrix = cov_matrix %*% t(cov_matrix)  # Make it positive semi-definite
rownames(cov_matrix) = colnames(cov_matrix) = 1:10

# Ensure the covariance matrix is symmetric
cov_matrix = (cov_matrix + t(cov_matrix)) / 2


  
mod = brms_cov_model(Chainset = 3, 
           Response = "mass", 
           FixedEffect = "height", 
           ID = "ID", 
           Matrix = cov_matrix,
           Family = "gaussian", 
           Data = md, 
           Seed = 0405)

#' }

```


```{r test-brms_cov_model}

#included below as a function

```

# mod_cov
```{r dev-mod_cov, eval=TRUE}
# Create a group (ID) variable
md = tibble::tibble(
  ID = as.factor(rep(1:10, each = 100))) %>% 

# Create a variables 
  dplyr::mutate(height = rnorm(1000, mean = 170, sd = 10),
         mass = 5 + 0.5 * height + rnorm(1000, mean = 0, sd = 5)) %>% 
  dplyr::mutate(height = height - mean(height))

# Create a covariance matrix (e.g., relatedness matrix)
cov_matrix = matrix(rnorm(10 * 10), 10, 10)
cov_matrix = cov_matrix %*% t(cov_matrix)  # Make it positive semi-definite
rownames(cov_matrix) = colnames(cov_matrix) = 1:10

# Ensure the covariance matrix is symmetric
cov_matrix = (cov_matrix + t(cov_matrix)) / 2


  
mod_cov = brms_cov_model(Chainset = 3, 
           Response = "mass", 
           FixedEffect = "height", 
           ID = "ID", 
           Matrix = cov_matrix,
           Family = "gaussian", 
           Data = md, 
           Seed = 0405)

save(mod_cov, file = "data/mod_cov.RData")

```

```{r function-mod_cov}
#' model with fixed effects and a random effect with a covariance matrix
#' @format A `brmsfit` object.
#' @source Generated using the `brms_cov_model` function.

"mod_cov"

```

```{r examples-mod_cov}

mod = data("mod_cov", package = "VarDecomp")

```

______

# var_decomp
```{r function-var_decomp}
#' Variance decomposition for brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#'
#' @return Returns a data frame with the summaries of posterior estimates.
#'
#' @export
#'
var_decomp = function(brmsfit){

  stopifnot("Input must be a brmsfit" =               
              inherits(brmsfit, "brmsfit"))
  
# Extract original data
  Data = brmsfit$data
  
  Data = Data %>% 
    dplyr::filter(dplyr::if_all(1:ncol(Data),~ !is.na(.)))
  
  
# Extract posterior samples
  PS = as.data.frame(brmsfit) %>% 
  dplyr::select(!dplyr::starts_with("r")) %>% 
  dplyr::select(!dplyr::contains("prior")) %>% 
  dplyr::select(!lp__)
 

if("Intercept" %in% colnames(PS)){PS = PS %>% dplyr::select(-Intercept)}

#Extract family
Family = brmsfit$family[[1]][1]

#Extract fixed effect names
PS_b = PS %>% 
  dplyr::select(dplyr::starts_with("b_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^b_")) %>%  
  dplyr::select(!Intercept)


  
FixedEffect = colnames(PS_b)


#Extract random effect names
PS_sd = PS %>% 
  dplyr::select(dplyr::starts_with("sd_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^sd_"))


RandomEffect = NULL
  
if(length(PS_sd) > 0){
  
  if(Family == "binomial" | Family == "poisson"){

  PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::select(-dplyr::contains("observationID")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))
  RandomEffect = colnames(PS_RE)
  
}else{

PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))
  RandomEffect = colnames(PS_RE)
}
}



#Extract random slope names
RandomSlope = NULL
 
if(!is.null(RandomEffect)){
  
PS_RS = PS_sd %>% 
  dplyr::rename_with(~ stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::select(!dplyr::ends_with("Intercept"))

if(length(PS_RS) > 0){

  RandomSlope = colnames(PS_RS)

  RandomSlope = gsub(paste0(RandomEffect, "_"), "",
                     RandomSlope)
}
} 



#Rename columns for tidying the data
PS = PS %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "^b_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "sd_")) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "_Intercept")) 


# Variance in fixed effects

## Create a dataframe with the values used by the model for fixed effects
if(is.null(RandomEffect)){
  
  if(Family == "binomial" | Family == "poisson"){
  FixedEffectData = Data %>%
  dplyr::select(-observationID) %>% 
  dplyr::select(-1)  #Removing the response variable

  } else {
  FixedEffectData = Data %>% 
  dplyr::select(-1)  #Removing the response variable
  }  

  } else {
    
    if(Family == "binomial" | Family == "poisson"){
      
  FixedEffectData = Data %>% 
  dplyr::select(c(setdiff(colnames(Data), RandomEffect))) %>% 
  dplyr::select(-observationID) %>% 
  dplyr::select(-1) #Removing the response variable
  
    } else {
  FixedEffectData = Data %>% 
  dplyr::select(c(setdiff(colnames(Data), RandomEffect))) %>% 
  dplyr::select(-1) #Removing the response variable

      
    }
  }
  
  if(Family == "binomial"){
    FixedEffectData = FixedEffectData %>% 
      dplyr::select(-1)} # Removing the 'trials' variable

## Specific for covariates with of character class 
suppressWarnings({  
  CharactersFE = FixedEffectData%>%
  dplyr::select(-dplyr::one_of(FixedEffect)) 
  })
  
  if(ncol(CharactersFE) == 0){
    
  } else {
  
for(i in colnames(CharactersFE)){
unique_values = unique(CharactersFE[[i]])

for (j in unique_values) {

  CharactersFE = CharactersFE %>% 
    dplyr::mutate(!!paste(j) := dplyr::if_else(CharactersFE[[i]] == j, 1,0)) %>% 
    dplyr::rename(!!paste0(i, j) := paste(j)) 
  
}
CharactersFE = CharactersFE 
}

FixedEffectData = dplyr::bind_cols(FixedEffectData,CharactersFE) %>% 
  dplyr::select_if(~ is.numeric(.))
}

## Calculate estimated variances for each fixed effect
for (i in colnames(FixedEffectData)){
  if (i %in% colnames(PS)) {
  
    PS[[paste0("var_", i)]] = 0
        
    for (j in 1:length(PS[[paste0("var_", i)]])){
      PS[[paste0("var_", i)]][j] = stats::var(PS[[i]][j] * FixedEffectData[[i]]) 
  }
  }
}

## Calculate total variance in fixed effects
  
# Total variance in fixed effects
FixedEffectNames = intersect(names(PS), paste0("var_", names(FixedEffectData)))

PS = PS %>% 
dplyr::mutate(var_FixedEffects = rowSums(dplyr::across(tidyselect::all_of(FixedEffectNames)), na.rm = TRUE))
    
  
# Calculate the estimated variances in random slope

if(!is.null(RandomEffect)){
if(!is.null(RandomSlope)){
  
  
  PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect, "_", RandomSlope) := (get(paste0(RandomEffect, "_", RandomSlope))^2 *
                  stats::var(FixedEffectData[[RandomSlope]])) +
                
                 (get(paste0(RandomEffect,"_", RandomSlope))^2 *
                  mean(FixedEffectData[[RandomSlope]])^2))
  }

}
           
# Variances in random effect
if(!is.null(RandomEffect)){
  
  # for models without random slopes
  if(is.null(RandomSlope)){ 
PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect) := 
     
                             get(paste0(RandomEffect))^2)
                } else {
  
        
        # for models with random slope (in Holger's paper on random slopes)
                 PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect) := 
                  
                  get(paste0(RandomEffect))^2 +
                  
              get(paste0("var_", RandomEffect, "_", RandomSlope)) +
                        
      2 * mean(FixedEffectData[[RandomSlope]]) *
                   
      get(paste0("cor_", RandomEffect, "_",
                            RandomSlope)) *
    
      get(paste0(RandomEffect)) *
      get(paste0(RandomEffect,"_", RandomSlope)) )

                }
}

                            
# Residual variance
if(Family == "gaussian"){
PS = PS %>% 
  dplyr::mutate(residual = sigma^2)

} else {
  if(Family == "binomial"){

    PS = PS %>% 
      dplyr::mutate(residual = observationID^2 + (pi^2/3))

    } else {
     if(Family== "poisson") {
       
      PS = PS %>% 
        dplyr::mutate(residual =  observationID^2 + 
                                    log(1/exp(Intercept)+1))
     
     } else {
       
       stop("`The family of this model is not yet supported by var_decomp function")
    
       
  }
  }
  }

# Total phenotypic variance
if(!is.null(RandomEffect)){
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           get(paste0("var_", RandomEffect)) + 
           residual) 

} else {
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           residual)   
}


# calculate R2 for fixed effects

for (i in FixedEffectNames){
        PS = PS %>% 
           dplyr::mutate(!!paste0("R2_", i) := get(paste0(i))/total_pv)
}

PS = PS %>% 
  dplyr::rename_with(~ stringr::str_replace(., "_var_", "_")) %>% 
  dplyr::mutate(R2_sum_fixed_effects = var_FixedEffects/ total_pv) 
                
      
# calculate R2 for random slopes
    if(!is.null(RandomSlope)){
      
      PS = PS %>%
        dplyr::mutate(!!paste0("R2_", RandomEffect, "_", RandomSlope) := 
                   get(paste0("var_", RandomEffect, "_", RandomSlope))/total_pv)
      } 
  

# calculate R2 for random effect
if(!is.null(RandomEffect)){
PS = PS %>% 
  dplyr::mutate(!!paste0("R2_",RandomEffect) := 
             get(paste0("var_", RandomEffect))/total_pv) 
}
# Residual
PS = PS %>% 
  dplyr::mutate(R2_residual = 
             residual/total_pv)


output = PS %>% 
  dplyr::select(-tidyselect::all_of(RandomEffect)) %>% 
  dplyr::select(-dplyr::starts_with("var_")) %>% 
  dplyr::select(-total_pv) %>% 
  dplyr::select(-residual) %>% 
  dplyr::select(-tidyselect::any_of("sigma"))

if(Family == "binomial" | Family == "poisson"){
  output = output %>% 
  select(-observationID)

}


return(output)   

}

```


```{r examples-var_decomp, eval=FALSE}

#' \dontrun{

md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = "sex", 
                 RandomEffect = "species",
                 Family = "gaussian", 
                 Data = md)

var_decomp(mod)

#' }

```


```{r test-var_decomp}
data("mod", package = "VarDecomp")
var_decomp(mod)

data("mod_RE", package = "VarDecomp")
var_decomp(mod_RE)

data("mod_RS", package = "VarDecomp")
var_decomp(mod_RS)


data("mod_cov", package = "VarDecomp")
var_decomp(mod_cov)

```

________

# model_summary
```{r function-model_summary}
#' Variance decomposition for brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#'
#' @return Returns a data frame with the summaries of posterior estimates.
#' @import posterior
#' @export
#'
model_summary = function(brmsfit){

  stopifnot("Input must be a brmsfit" =               
              inherits(brmsfit, "brmsfit"))
  

output = VarDecomp::var_decomp(brmsfit)

EstSummary = posterior::summarise_draws(output) %>% 
  dplyr::select(variable, mean, median, sd) 
  
#Highest probability density interval
HPDInt = as.data.frame(coda::HPDinterval(mcmcr::as.mcmc(output, combine_chains = TRUE))) %>% 
  tibble::rownames_to_column(var = "variable")

  EstSummary = dplyr::left_join(EstSummary, HPDInt, by = "variable") %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), \(x) round(x, 3))) %>% 
  dplyr::rename(lower_HPD = lower, upper_HPD = upper) %>% 
        dplyr::filter(!grepl("sigma", variable))
  
return(EstSummary)   

}

```


```{r examples-model_summary, eval=FALSE} 
#' \dontrun{

md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = "sex", 
                 RandomEffect = "species",
                 Family = "gaussian", 
                 Data = md)

model_summary(mod)

#' }
```


```{r test-model_summary}

data("mod", package = "VarDecomp")
model_summary(mod)

data("mod_RE", package = "VarDecomp")
model_summary(mod_RE)

data("mod_RS", package = "VarDecomp")
model_summary(mod_RS)


data("mod_cov", package = "VarDecomp")
model_summary(mod_cov)

```

________

# compare_slopes

```{r function-compare_slopes}

#' Compare slope values of different brms models
#'
#' @param ... brms models to be compared
#' 
#' @param Slope A string containing the name of the covariate to have the slopes compared between models
#'
#' @return Returns a table of values with the log(slope model 1/slope model 2) 
#' @export 
#'

compare_slopes = function(..., Slope){

  # Capture all the arguments into a list
  brmsfit_list = list(...)

  # Check if all elements are of class 'brmsfit'
  stopifnot("All inputs must be brmsfit objects" = 
              (sapply(brmsfit_list, inherits, "brmsfit"))) 
  
  stopifnot("This function allows comparing only two models at a time" = 
              length(brmsfit_list) == 2) 
  
  stopifnot("Slope must be a string" = 
             inherits(Slope, "character"))
  
  
mean_slope_mod1 = mean(as.data.frame(brmsfit_list[[1]])[[paste0("b_", Slope)]],na.rm=TRUE)
mean_slope_mod2 = mean(as.data.frame(brmsfit_list[[2]])[[paste0("b_", Slope)]],na.rm=TRUE)
  

  lnR = log(mean_slope_mod1/mean_slope_mod2)


return(lnR)  

}

```


```{r examples-compare_slopes, eval=FALSE}
#' \dontrun{

md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod1 = brms_model(Chainset = 2,
                   Response = "mass", 
                   FixedEffect = "sex", 
                   Family = "gaussian", 
                   Data = md)

mod2 = brms_model(Chainset = 2,
                   Response = "mass", 
                   FixedEffect = "sex",
                   RandomSlope = c("sex","species"),
                   Family = "gaussian", 
                   Data = md)

compare_slopes(mod1, mod2, Slope = "sex")

#' }
```


```{r test-compare_slopes}
data("mod_RE", package = "VarDecomp")
data("mod_RS", package = "VarDecomp")

compare_slopes(mod_RE, mod_RS, Slope = "height")
```

________

# model_fit

```{r function-model_fit} 
#' Perform model fit checks for brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#' @param Group A string containing the name of a grouping variable for the visualization of a posterior predictive check plot (e.g. "sex"). To add multiple grouping variables, use c() (e.g. c("sex", "species")). 
#' @param Prior A logical argument defining whether the `brmsfit` contains prior samples. If set to `TRUE` it will produce plots comparing the log distributions of priors and posterior samples for each covariate. 
#'
#' @return Returns a list containing (a) the maximum R-hat value, (b) the minimum effective sample size, (c) traceplots, (d) posterior predictive check plots, and (e) prior and posterior sample plots (if priors are available).
#' @export 
#' 
model_fit = function(brmsfit, Group = NULL, Prior = FALSE){


# R-hat and effective sample size

convergence = tibble::tribble(~Rhat, ~EffectiveSampleSize,
               max(posterior::summarise_draws(brmsfit)$rhat), 
               min(posterior::summarise_draws(brmsfit)$ess_bulk))

# Trace plots
traceplot = bayesplot::mcmc_trace(posterior::as_draws_df(brmsfit), 
           pars = dplyr::vars(tidyselect::starts_with("b"), 
                       tidyselect::starts_with("sd"), 
                       -tidyselect::contains("prior")),
           np = bayesplot::nuts_params(brmsfit),
           facet_args = list(ncol = 2), 
           size = 0.15) 

nd = nrow(as.data.frame(brmsfit))

# Posterior predictive checks
ppDens = rstanarm::pp_check(brmsfit, type = "dens_overlay", ndraws = (nd*0.2)) 

ppLoo = rstanarm::pp_check(brmsfit, type = "loo_pit_qq") 

if(!is.null(Group)){

for (i in Group){
plot = rstanarm::pp_check(brmsfit, type = "violin_grouped",group= i) +
  ggtitle(i)
assign(paste0("GroupPlot_", i), plot) 
}

ppGroup = list()   

GroupNames = ls(pattern = "^GroupPlot")
for (i in GroupNames) {
    ppGroup[[i]] = get(i)
}
}

# Prior samples
if(Prior == TRUE){
priordraws = brms::prior_draws(brmsfit) %>% 
  dplyr::select(tidyselect::starts_with("sd_"))  
  
if(length(priordraws)==0){
  priorsample = "No prior samples to plot"
}else{
 priordraws = priordraws %>% 
 tidyr::pivot_longer(cols = 1, names_to = "variable", values_to = "value")%>%
  tibble::add_column(name = "prior")

posteriordraws = as.data.frame(brmsfit) %>% 
    dplyr::select(tidyselect::starts_with("sd")) %>%
    dplyr::select(tidyselect::contains("Intercept")) %>%
    dplyr::rename_with(~ stringr::str_remove_all(., "__Intercept")) %>% 
  tidyr::gather(key = "variable", value = "value") %>%
  tibble::add_column(name = "posterior")

priorposterior= dplyr::bind_rows(priordraws,posteriordraws) %>% 
  dplyr::mutate(value=log(value)) %>% 
  dplyr::rename_with(~ stringr::str_remove_all(., "sd_"))



priorsample = 
  ggplot2::ggplot(priorposterior, ggplot2::aes(value, fill = name, color = name)) +
  ggplot2::geom_density(alpha=0.6, linewidth=0.8) +
  ggplot2::scale_fill_manual(values=c("#B3CDE0","#8ECAE6")) +
  ggplot2::scale_color_manual(values=c("#B3CDE0","#8ECAE6")) +
  ggplot2::theme_test()+
  ggplot2::facet_wrap(~variable)
 
}

}


if(is.null(Group)){
  if(isFALSE(Prior)){
  output = list(convergence,
            traceplot,
            ppDens, 
            ppLoo)
  names(output) = c("R-hat and Effective sample size", "Traceplots plot", "Posterior predictive check - Density overlay plot", "Posterior predictive check - LOO-PIT-QQ plot")
  }else{
    output = list(convergence,
            traceplot,
            ppDens, 
            ppLoo, 
            priorsample)
      names(output) = c("R-hat and Effective sample size", "Traceplots plot", "Posterior predictive check - Density overlay plot", "Posterior predictive check - LOO-PIT-QQ plot","Prior samples plot") 
    }
}else{
  if(isFALSE(Prior)){

    output = list(convergence,
            traceplot,
            ppDens, 
            ppLoo, 
            ppGroup)
      names(output) = c("R-hat and Effective sample size", "Traceplots plot", "Posterior predictive check - Density overlay plot", "Posterior predictive check - LOO-PIT-QQ plot", "Posterior predictive check - Group density overlay plot")
  }else{
      output = list(convergence,
            traceplot,
            ppDens, 
            ppLoo, 
            ppGroup, 
            priorsample)
      
       names(output) = c("R-hat and Effective sample size", "Traceplots plot", "Posterior predictive check - Density overlay plot", "Posterior predictive check - LOO-PIT-QQ plot", "Posterior predictive check - Group density overlay plot", "Prior samples plot")
  }
}

return(output)
  
}
```




```{r examples-model_fit, eval=FALSE}
#' \dontrun{

md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, height, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))


# Without random effects

mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = c("sex","height"), 
                 Family = "gaussian", 
                 Data = md,
                 PriorSamples = TRUE)

model_fit(mod, Group = "sex", Prior = TRUE)

#' }
```


```{r test-model_fit}

data("mod", package = "VarDecomp")
model_fit(mod)

data("mod_RE", package = "VarDecomp")
model_fit(mod_RE)

data("mod_RS", package = "VarDecomp")
model_fit(mod_RS)

data("mod_cov", package = "VarDecomp")
model_fit(mod_cov)

```

_____

# plot_intervals
```{r function-plot_intervals}
#' Plot probability density intervals for fixed effects of brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#' @return Returns a density plot with z-transformed fixed effect estimates.
#' @export 
#' 

plot_intervals = function(brmsfit){

stopifnot("Input must be a brmsfit" = inherits(brmsfit, "brmsfit"))
  
  
#Extract fixed effects posterior samples from brmsfit
PS = as.data.frame(brmsfit) %>% 
  dplyr::select(dplyr::starts_with("b_")) %>% 
  dplyr::select(!dplyr::contains("Intercept")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^b_"))

#Extract fixed effects observed data from brmsfit
Data = brmsfit$data 
Data = Data %>% 
  dplyr::filter(dplyr::if_all(1:ncol(Data),~ !is.na(.))) %>% 
  dplyr::select(-1)

if(brmsfit$family[[1]][1] == "binomial"){
  Data = Data %>%
  dplyr::select(-1)
}


# Standardize the slopes for the standard deviation of each covariate (Z transformation)
for(i in colnames(PS)){
  PS = PS %>% 
  dplyr::mutate(!!paste(i) := get(paste(i)) * sd(Data[[i]]))
}

# Turn to long format and order levels for the plot 

PS = PS %>%
  tidyr::pivot_longer(cols = tidyselect::everything(), 
  names_to = "FixedEffect",
  values_to = "Slope")


# Plot
ggplot2::ggplot(PS,ggplot2::aes(y = FixedEffect, x = Slope)) +  
  ggdist::stat_halfeye(.width = c(.5, .95))+
  ggplot2::geom_vline(xintercept=0,color = "red")+
  ggplot2::labs(x = "Fixed effects slopes")+
  ggplot2::theme_test()  
}



```

```{r examples-plot_intervals, eval=FALSE} 
#' \dontrun{
md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = "sex", 
                 RandomEffect = "species",
                 Family = "gaussian", 
                 Data = md)

plot_intervals(mod)

#' }

```


```{r test-plot_intervals}
data("mod", package = "VarDecomp")
plot_intervals(mod)

data("mod_RE", package = "VarDecomp")
plot_intervals(mod_RE)

data("mod_RS", package = "VarDecomp")
plot_intervals(mod_RS)


data("mod_cov", package = "VarDecomp")
plot_intervals(mod_cov)

```

_____


# plot_R2
```{r function-plot_R2}
#' Plot R2 values of brms models
#'
#' @param PosteriorSamples The estimates of a brms model after variance decomposition. You can use VarDecomp::brms_model() to produce a brmsfit and then VarDecomp::var_decomp() to produce the posterior samples. 
#' @param Colors A vector with string of the colors to be attributed to each variable ordered by R2, with residual at the end (e.g. c("blue", "green", "gray")).
#' @return Returns a bar plot with the proportion of variance explained by each variable.
#' @export 
#' 

plot_R2 = function(PosteriorSamples, Colors = NULL){

stopifnot("Input must be a data frame containing estimates after variance decomposition. You can use VarDecomp::var_decomp() to produce the input data." = inherits(PosteriorSamples, "data.frame"))

stopifnot("Input must be a data frame containing estimates after variance decomposition. You can use VarDecomp::var_decomp() to produce the input data." = any(stringr::str_detect(names(PosteriorSamples), "R2")) == TRUE) 

if(!is.null(Colors)){
stopifnot("Colors input must be a vector containing strings with the colors to be attributed to each category in the stacked bar plot (e.g. c(`blue`, `green`, `gray`))." = inherits(Colors, "character"))
}  
  
PS = PosteriorSamples %>% 
  dplyr::select(dplyr::starts_with("R2_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^R2_")) %>% 
  dplyr::select(!sum_fixed_effects) %>% 
  dplyr::summarise(dplyr::across(tidyselect::everything(), mean, na.rm = TRUE))

for (i in colnames(PS)) {
  RS = unlist(strsplit(i, "_"))
  
  # Check if both parts exist as separate columns
  if (length(RS) == 2 && all(RS %in% colnames(PS))) {
    # Remove the concatenated column
    PS = PS %>% 
    dplyr::select(-all_of(i))
  }
  }  

PS = PS %>%
  tidyr::pivot_longer(cols = everything(), 
  names_to = "Variable",
  values_to = "R2")

PS = PS %>%
  dplyr::arrange(R2) %>% 
  dplyr::mutate(ID = "")

PS = PS %>%
  dplyr::mutate(Variable = factor(Variable, 
  levels = c(setdiff(PS$Variable, "residual"), "residual")))

 if(is.null(Colors)){
  variable_colors = setNames(rep("lightgrey", length(levels(PS$Variable))), levels(PS$Variable))
  variable_colors[names(variable_colors) != "residual"] = scales::hue_pal()(length(levels(PS$Variable)) - 1)
 }  else {
  variable_colors = Colors
}

ggplot2::ggplot(PS, ggplot2::aes(x = ID, y = R2, fill=Variable)) +
ggplot2::geom_bar(stat="identity") +

ggplot2::geom_text(ggplot2::aes(label = round(R2*100, 2)), 
              position = ggplot2::position_fill(vjust = 0.5), 
              color = "white", size = 3) +
ggplot2::scale_fill_manual(values = variable_colors) +
ggplot2::labs(x = NULL, y = "Proportion of total variance explained")+
ggplot2::theme_test()
}

```

```{r examples-plot_R2, eval=FALSE} 
#' \dontrun{
md = dplyr::starwars

# Centering variables
md = md %>% 
  dplyr::select(mass, sex, species) %>% 
  dplyr::mutate(mass = log(mass),
         sex = dplyr::recode(sex, "male" = 1, 
                      "female" = -1, 
                      "hermaphroditic" = 0,
                      "none" = as.numeric(NA)))
  
  
mod = brms_model(Chainset = 2,
                 Response = "mass", 
                 FixedEffect = "sex", 
                 RandomEffect = "species",
                 Family = "gaussian", 
                 Data = md)

PosteriorSamples = var_decomp(mod)
plot_R2(PosteriorSamples)

#' }

```


```{r test-plot_R2}
data("mod", package = "VarDecomp")
plot_R2(var_decomp(mod))

data("mod_RE", package = "VarDecomp")
plot_R2(var_decomp(mod_RE))

data("mod_RS", package = "VarDecomp")
plot_R2(var_decomp(mod_RS))

data("mod_cov", package = "VarDecomp")
plot_R2(var_decomp(mod_cov))

```