---
title: "VarDecomp"
output: html_document
editor_options: 
  chunk_output_type: console
  
---


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
options(rmarkdown.html_vignette.check_title = FALSE)
```


```{r function-testfunction}
testfunction = function(){

emojis = c("\U1F600", "\U1F604", "\U1F601", "\U1F643", "\U1F609", "\U1F60A", "\U1F929", "\U1F917", "\U1F92D", "\U1F973", "\U1F920", "\U1F978", "\U1F60E", "\U1F913", "\U1F47D", "\U1F638", "\U1F596", "\U1F44C", "\U270C", "\U1F44D", "\U1F44F", "\U1F64C", "\U1F40C", "\U1F41B", "\U1F41E", "\U1F997")  

print(paste("No problem", sample(emojis, size = 1)))
}
```

# brms_model: function for running brms models

```{r function-brms_model}

#' Run a brms model
#'
#' @param Data A data frame containing the data - covariates should be centered to a the mean or to a meaningful zero (see Schielzeth H. 2010. Simple means to improve the interpretability of regression coefficients. Methods Ecol Evol. 1:103â€“113. doi:10.1111/j.2041-210X.2010.00012.x.).
#' @param Response String with the name of the column in Data containing the response variable (e.g. "mass"). 
#' @param FixedEffect String with the name of the column in Data containing the fixed effect variable (e.g. "height"). To add multiple fixed effects, use c() (e.g. c("height", "sex")). 
#' @param RandomEffect String with the name of the column in Data containing the random effect variable (e.g. "species"). The current package version allows the use of a single random effect.
#' @param RandomSlope String with the name of the column in Data containing the covariate to be added as a random slope (e.g. "height"). The current package version allows the use of a single random slope.
#' @param Chainset String to define the number of iterations. Start with "test" (warmup=10; iter=110; thin=10; chains=2) and increase as needed until convergence: "long"(warmup=15000; iter=30000; thin=15; chains=2); "longer"(warmup=30000; iter=60000; thin=30; chains=2); "longest" (warmup=60000; iter=120000; thin=60; chains=2).
#' @param Family String to define the family function in the brms model. Current supported families: "gaussian", "binomial", "poisson".
#' @param Seed Numeric and optional. Set a seed in order to repeat the results from the model when running it more than once. 
#' @param Trials The total number of trials in a binomial model. The number of successes should be inputed on Response.
#'
#' @return Returns a brmsfit
#' @export 
#'
brms_model = function(Data, Response, FixedEffect, RandomEffect = NULL, RandomSlope = NULL, Chainset, Family = "gaussian", Seed = sample(1000:9999, 1), Trials = NA){
stopifnot("`Data` must be a data frame" =               
              inherits(Data, "data.frame"))
  
stopifnot("`Response` must be a string" =               
              inherits(Response, "character"))

if(Family == "binomial"){
  Successes = Data[[Response]]
  stopifnot("Family 'binomial' requires an integer response variable." =inherits(Successes, "integer"))
}

if(Family == "binomial"){
  Attempts = Data[[Trials]]
  stopifnot("Family 'binomial' requires an integer trial variable." =inherits(Attempts, "integer"))
  }

  
if(Family == "poisson"){
  Resp = Data[[Response]]
  stopifnot("Family 'poisson' requires an integer response variable." =inherits(Resp, "integer"))
}


stopifnot("`FixedEffect` must be a string" =               
              inherits(FixedEffect, "character"))

if(!is.null(RandomEffect)) {stopifnot("`RandomEffect` must be a string" =               
              inherits(RandomEffect, "character"))}

if(!is.null(RandomSlope)){stopifnot("`RandomSlope` must be a string" =               
              inherits(RandomSlope, "character"))}

stopifnot("`Chainset` must be a string (options are 'test', 'long, 'longer', 'longest')" =               
              inherits(Chainset, "character"))

stopifnot("`Family` must be a string" =               
              inherits(Family, "character"))

if(Family == "binomial" && is.na(Trials)){
stop("Binomial models require the total number of trials (use `Trial =` for inputing the corresponding variable) and a response variable with the number of successes (use `Response =` for inputing the variable with the count of successes).")}


stopifnot("`Seed` must be a string" =               
              inherits(Seed, "numeric"))

testfunction()
  
if(Chainset=="longest"){warmup=60000; iter=120000; thin=60; chains=2}
if(Chainset=="longer"){warmup=30000; iter=60000; thin=30; chains=2}
if(Chainset=="long"){warmup=15000; iter=30000; thin=15; chains=2}
if(Chainset=="test"){warmup=10; iter=110; thin=10; chains=2}


# Add an observation ID for models of binomial or poisson families
if(Family == "binomial" | Family == "poisson"){

Data = Data %>%
  dplyr::mutate(observationID = as.factor(dplyr::row_number(Data)))

}


# Construct model formula if binomial family 
if(Family == "binomial"){

  bfform = 
    
    if(is.null(RandomEffect)) {
      paste0(Response, " | trials( ", Trials, ") ~ ", paste(FixedEffect, collapse = " + "), " + (1|observationID)")
      } else {
        if(is.null(RandomSlope)){
        paste0(Response, " | trials( ", Trials, ") ~ ", 
               paste(FixedEffect, collapse = " + "),
        "+ ( 1 | ", RandomEffect," ) + (1|observationID)")
          } else {
          paste0(Response, " | trials( ", Trials, ") ~ ",
                 paste(FixedEffect, collapse = " + "),
                 "+ ( 1 +", RandomSlope, " | ", 
                 RandomEffect," ) + (1|observationID)")}}

} else {

# Construct the formula object if poisson family
  
if(Family == "poisson"){

bfform = 
    
    if(is.null(RandomEffect)) {
      paste0(Response, " ~ ", paste(FixedEffect, collapse = " + "), " + (1|observationID)")
      } else {
        if(is.null(RandomSlope)){
        paste0(Response, " ~ ", 
               paste(FixedEffect, collapse = " + "),
        "+ ( 1 | ", RandomEffect," ) + (1|observationID)")
          } else {
          paste0(Response, " ~ ",
                 paste(FixedEffect, collapse = " + "),
                 "+ ( 1 +", RandomSlope, " | ", 
                 RandomEffect," ) + (1|observationID)")}}
} else {
  
# Construct the formula object for other model families
  

  bfform = 
    
    if(is.null(RandomEffect)) {
      paste0(Response, "~", paste(FixedEffect, collapse = " + "))
      } else {
        if(is.null(RandomSlope)){
        paste0(Response, "~", paste(FixedEffect, collapse = " + "),
        "+ ( 1 | ", RandomEffect," )")
          } else {
          paste0(Response, "~",
                 paste(FixedEffect, collapse = " + "),
                 "+ ( 1 +", RandomSlope, " | ", RandomEffect," )")}}
        
}
}

mod =  brms::brm(brms::bf(stats::as.formula(bfform)),
                  family = Family,
                  data = Data, 
                  warmup = warmup,
                  iter = iter, 
                  thin=thin, 
                  chains = chains, 
                  init = "random", 
                  seed = Seed, 
                  cores = parallel::detectCores(), 
                  control = list(adapt_delta = 0.999), 
                  sample_prior = TRUE)

brmsfit = mod

return(brmsfit)

}

```

### Examples
```{r examples-brms_model, warning=FALSE, message=FALSE}

# With random slope
md = dplyr::starwars

mod = brms_model(Chainset = "long", 
           Response = "mass", 
           FixedEffect = c("sex","height"), 
           RandomEffect = "species", 
           RandomSlope = "height",
           Family = "gaussian", 
           Data = md, 
           Seed = 0405)

print(mod)

plot(mod)

```

### Tests
```{r test-brms_model}

md = dplyr::starwars


# Without random effects

mod = brms_model(Chainset = "long", 
           Response = "mass", 
           FixedEffect = c("sex","height"), 
           Family = "gaussian", 
           Data = md, 
          Seed = 0405)

print(mod)

plot(mod)

# With random effect
mod_RE = brms_model(Chainset = "long", 
           Response = "mass", 
           FixedEffect = c("sex","height"), 
           RandomEffect = "species", 
           Family = "gaussian", 
           Data = md, 
           Seed = 0405)

print(mod_RE)

plot(mod_RE)


# With random slope
mod_RS = brms_model(Chainset = "long", 
           Response = "mass", 
           FixedEffect = c("sex","height"), 
           RandomEffect = "species", 
           RandomSlope = "height",
           Family = "gaussian", 
           Data = md, 
          Seed = 0405)

print(mod_RS)

plot(mod_RS)



```

```{r dev, eval=FALSE}
save(mod, file="mod.RData")
save(mod_RE, file="mod_RE.RData")
save(mod_RS, file="mod_RS.RData")

load(file="mod.RData")
load(file="mod_RE.RData")
load(file="mod_RS.RData")
```


________

# var_decomp = function for variance decomposition
```{r function-var_decomp}
#' Variance decomposition for brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#'
#' @return Returns a data frame with the summaries of posterior estimates.
#'
#' @export
#'
var_decomp = function(brmsfit){

# Extract original data
  Data = brmsfit$data
  
  Data = Data %>% 
    dplyr::filter(dplyr::if_all(1:ncol(Data),~ !is.na(.)))
  
  
# Extract posterior samples
  PS = as.data.frame(brmsfit) %>% 
  dplyr::select(!dplyr::starts_with("r")) %>% 
  dplyr::select(!dplyr::contains("prior")) %>% 
  dplyr::select(!lp__)
 

if("Intercept" %in% colnames(PS)){PS = PS %>% dplyr::select(-Intercept)}

#Extract family
Family = brmsfit$family[[1]][1]

#Extract fixed effect names
PS_b = PS %>% 
  dplyr::select(dplyr::starts_with("b_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^b_")) %>%  
  dplyr::select(!Intercept)

FixedEffect = colnames(PS_b)

#Extract random effect names
PS_sd = PS %>% 
  dplyr::select(dplyr::starts_with("sd_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^sd_"))

if(Family == "binomial" | Family == "poisson"){

  PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::select(!dplyr::contains("observationID")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))

} else {

PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))
}

if(ncol(PS_RE) == 0){RandomEffect = NULL
} else {
  RandomEffect = colnames(PS_RE)
}


#Extract random slope names

PS_RS = PS_sd %>% 
  dplyr::rename_with(~ stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::select(!dplyr::ends_with("Intercept"))

if(ncol(PS_RS) == 0){RandomSlope = NULL
} else {
  RandomSlope = colnames(PS_RS)
RandomSlope = gsub(paste0(RandomEffect, "_"), "", RandomSlope)
}
  



#Rename columns for tidying the data
PS = PS %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "^b_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "sd_")) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "_Intercept")) 


# Variance in fixed effects

## Create a dataframe with the values used by the model for fixed effects
if(!is.null(RandomEffect)){
  FixedEffectData = Data %>% 
  dplyr::select(c(setdiff(colnames(Data), RandomEffect))) %>% 
  dplyr::select(-1)  #Removing the response variable
} else {
  FixedEffectData = Data %>% 
  dplyr::select(-1)  #Removing the response variable
  }
  
## Specific for covariates with of character class 
suppressWarnings({  CharactersFE = FixedEffectData%>%
  dplyr::select(-dplyr::one_of(FixedEffect)) })
  
  if(ncol(CharactersFE) == 0){
    
  } else{
  
for(i in colnames(CharactersFE)){
unique_values = unique(CharactersFE[[i]])

for (j in unique_values) {

  CharactersFE = CharactersFE %>% 
    dplyr::mutate(!!paste(j) := dplyr::if_else(CharactersFE[[i]] == j, 1,0)) %>% 
    dplyr::rename(!!paste0(i, j) := paste(j)) 
  
}
CharactersFE = CharactersFE 
}

FixedEffectData = dplyr::bind_cols(FixedEffectData,CharactersFE) %>% 
  dplyr::select_if(~ is.numeric(.))
}

## Calculate estimated variances for each fixed effect

for (i in colnames(FixedEffectData)){
  if (i %in% colnames(PS)) {
        PS = PS %>% 
           dplyr::mutate(!!paste0("var_", i) := get(paste0(i))*
               var(FixedEffectData[[paste0(i)]]))
  
  }
  }

# Total variance in fixed effects
FixedEffectNames = intersect(names(PS), paste0("var_", names(FixedEffectData)))

PS = PS %>% 
dplyr::mutate(var_FixedEffects = rowSums(dplyr::across(tidyselect::all_of(FixedEffectNames)), na.rm = TRUE))
  
  
# Calculate the estimated variances in random slope

if(!is.null(RandomSlope)){
  
  
  PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect, "_", RandomSlope) := (get(paste0(RandomEffect, "_", RandomSlope))^2 *
                  var(FixedEffectData[[RandomSlope]])) +
                
                 (get(paste0(RandomEffect,"_", RandomSlope))^2 *
                  mean(FixedEffectData[[RandomSlope]])))
  }


           
# Variances in random effect
if(!is.null(RandomEffect)){
PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect) := 
           
        # for models without random slopes
          ifelse(is.null(RandomSlope), 
                 get(paste0(RandomEffect))^2,
        
        # for models with random slope (in Holger's paper on random slopes)
                 (get(paste0(RandomEffect))^2) +
                  
              (get(paste0("var_", RandomEffect, "_", RandomSlope))) +
                        
                (get(paste0("cor_", RandomEffect, "_",
                            RandomSlope))) *
                   get(paste0(RandomEffect)) *
                   get(paste0(RandomEffect,"_", RandomSlope)) *
                   2 *  mean(FixedEffectData[[RandomSlope]])))
}
                            
# Residual variance
if(Family == "gaussian"){
PS = PS %>% 
  dplyr::mutate(residual = sigma^2)

} else {
  if(Family == "binomial"){

    PS = PS %>% 
      dplyr::mutate(residual = observationID^2 + (pi^2/3))

    } else {
     if(Family== "poisson") {
       
      PS = PS %>% 
        dplyr::mutate(residual =  observationID^2 + 
                                    log(1/exp(Intercept)+1))
     
     } else {
       
       stop("`The family of this model is not yet supported by var_decomp function")
    
       
  }
  }
  }

# Total phenotypic variance
if(!is.null(RandomEffect)){
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           get(paste0("var_", RandomEffect)) + 
           residual) 

} else {
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           residual)   
}


# calculate R2 for fixed effects

for (i in FixedEffectNames){
        PS = PS %>% 
           dplyr::mutate(!!paste0("R2_", i) := get(paste0(i))/total_pv)
}

PS = PS %>% 
dplyr::mutate(R2_FixedEffects = rowSums(dplyr::across(tidyselect::all_of(paste0("R2_", FixedEffectNames))), na.rm = TRUE))%>%          dplyr::rename_with(~stringr::str_replace_all(., "_var_", "_"), dplyr::contains("_var_"))

# calculate R2 for random slopes
    if(!is.null(RandomSlope)){
      
      PS = PS %>%
        dplyr::mutate(!!paste0("R2_", RandomEffect, "_", RandomSlope) := 
                   get(paste0("var_", RandomEffect, "_", RandomSlope))/total_pv)
      } 
  

# calculate R2 for random effect
if(!is.null(RandomEffect)){
PS = PS %>% 
  dplyr::mutate(!!paste0("R2_",RandomEffect) := 
             get(paste0("var_", RandomEffect))/total_pv) 
}
# Residual
PS = PS %>% 
  dplyr::mutate(R2_residual = 
             residual/total_pv)


output = PS %>% 
  dplyr::select(-tidyselect::all_of(RandomEffect)) %>% 
  dplyr::select(-dplyr::starts_with("var_")) %>% 
  dplyr::select(-total_pv) %>% 
  dplyr::select(-residual)




EstSummary = posterior::summarise_draws(output) %>% 
  dplyr::select(variable, mean, median, sd) 
  
  
#Highest probability density interval
HPDInt = as.data.frame(coda::HPDinterval(mcmcr::as.mcmc(output, combine_chains = TRUE))) %>% 
  tibble::rownames_to_column(var = "variable")

EstSummary = dplyr::left_join(EstSummary, HPDInt, by = "variable") %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 3)) %>% 
  dplyr::rename(lower_HPD = lower, upper_HPD = upper) 



return(print(EstSummary))   

}



```

### Examples
```{r examples-var_decomp}
#var_decomp(mod_RS)
```

### Tests
```{r test-var_decomp}
#var_decomp(mod)
#var_decomp(mod_RE)
#var_decomp(mod_RS)
```


# Inflate
```{r development-inflate, eval=FALSE}
# Execute in the console directly - keep eval=FALSE to avoid infinite loop
fusen::inflate(flat_file = "dev/VarDecomp_package.Rmd", vignette_name = "Vignette")
```