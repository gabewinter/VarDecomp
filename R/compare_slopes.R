# WARNING - Generated by {fusen} from dev/VarDecomp_package.Rmd: do not edit by hand


#' Compare slope values of different brms models
#'
#' @param ... brms models to be compared
#' 
#' @param Slope A string containing the name of the covariate to have the slopes compared between models
#'
#' @return Returns a table of values with the log(slope model 1/slope model 2) 
#' @export 
#'
#' @examples
#'
#' # Simulate data
#' md = tibble::tibble(
#'   group = factor(sample(1:10, 1000, replace = TRUE)),
#'   f_var = factor(sample(1:3, 1000, replace = TRUE)),
#'   n_var = rnorm(1000, mean = 0, sd = 1),
#'   resp = rnorm(1000, mean = 10, sd = 3))
#'
#' # Run model without random slope
#' mod = brms_model(Response = "resp", 
#'                  FixedEffect = c("f_var","n_var"), 
#'                  RandomEffect = "group", 
#'                  Family = "gaussian", 
#'                  Data = md)
#'
#' # Run model with random slope
#' mod_RS = brms_model(Response = "resp", 
#'                  FixedEffect = c("f_var","n_var"), 
#'                  RandomSlope = c("n_var", "group"),
#'                  Family = "gaussian", 
#'                  Data = md)
#'
#' compare_slopes(mod, mod_RS, Slope = "n_var")
#'

compare_slopes = function(..., Slope){

  # Capture all the arguments into a list
  brmsfit_list = list(...)

  # Check if all elements are of class 'brmsfit'
  stopifnot("All inputs must be brmsfit objects" = 
              (sapply(brmsfit_list, inherits, "brmsfit"))) 
  
  stopifnot("This function allows comparing only two models at a time" = 
              length(brmsfit_list) == 2) 
  
  stopifnot("Slope must be a string" = 
             inherits(Slope, "character"))
  
  
mean_slope_mod1 = mean(as.data.frame(brmsfit_list[[1]])[[paste0("b_", Slope)]],na.rm=TRUE)
mean_slope_mod2 = mean(as.data.frame(brmsfit_list[[2]])[[paste0("b_", Slope)]],na.rm=TRUE)
  

  lnR = log(mean_slope_mod1/mean_slope_mod2)


return(lnR)  

}

