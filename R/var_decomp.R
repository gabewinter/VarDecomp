# WARNING - Generated by {fusen} from dev/VarDecomp_package.Rmd: do not edit by hand

#' Variance decomposition for brms models
#'
#' @param brmsfit The output of a brms model. You can use VarDecomp::brms_model() to produce a brmsfit. 
#'
#' @return Returns a data frame with the summaries of posterior estimates.
#'
#' @export
#'
#' @examples
#'
#' md = dplyr::starwars
#'
#' # Centering variables
#' md = md %>% 
#'   dplyr::select(mass, sex, species) %>% 
#'   dplyr::mutate(mass = log(mass),
#'          sex = dplyr::recode(sex, "male" = 1, 
#'                       "female" = -1, 
#'                       "hermaphroditic" = 0,
#'                       "none" = as.numeric(NA)))
#'   
#'   
#' mod = brms_model(Response = "mass", 
#'            FixedEffect = "sex", 
#'            RandomEffect = "species",
#'            Family = "gaussian", 
#'            Data = md)
#'
#' var_decomp(mod)
var_decomp = function(brmsfit){

  stopifnot("Input must be a brmsfit" =               
              inherits(brmsfit, "brmsfit"))
  
# Extract original data
  Data = brmsfit$data
  
  Data = Data %>% 
    dplyr::filter(dplyr::if_all(1:ncol(Data),~ !is.na(.)))
  
  
# Extract posterior samples
  PS = as.data.frame(brmsfit) %>% 
  dplyr::select(!dplyr::starts_with("r")) %>% 
  dplyr::select(!dplyr::contains("prior")) %>% 
  dplyr::select(!lp__)
 

if("Intercept" %in% colnames(PS)){PS = PS %>% dplyr::select(-Intercept)}

#Extract family
Family = brmsfit$family[[1]][1]

#Extract fixed effect names
PS_b = PS %>% 
  dplyr::select(dplyr::starts_with("b_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^b_")) %>%  
  dplyr::select(!Intercept)


  
FixedEffect = colnames(PS_b)


#Extract random effect names
PS_sd = PS %>% 
  dplyr::select(dplyr::starts_with("sd_")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "^sd_"))

  PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::select(-dplyr::contains("observationID")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))

if(ncol(PS_RE) != 0){
if(Family == "binomial" | Family == "poisson"){

} else {

PS_RE = PS_sd %>% 
  dplyr::select(dplyr::ends_with("Intercept")) %>% 
  dplyr::rename_with(~ stringr::str_remove(., "__Intercept"))
}

if(ncol(PS_RE) == 0){RandomEffect = NULL
} else {
  RandomEffect = colnames(PS_RE)
}
}

#Extract random slope names

PS_RS = PS_sd %>% 
  dplyr::rename_with(~ stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::select(!dplyr::ends_with("Intercept"))

if(ncol(PS_RS) == 0){RandomSlope = NULL
} else {
  RandomSlope = colnames(PS_RS)
RandomSlope = gsub(paste0(RandomEffect, "_"), "", RandomSlope)
}
  



#Rename columns for tidying the data
PS = PS %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "^b_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "sd_")) %>% 
  dplyr::rename_with(~stringr::str_replace_all(., "__", "_")) %>% 
  dplyr::rename_with(~stringr::str_remove_all(., "_Intercept")) 


# Variance in fixed effects

## Create a dataframe with the values used by the model for fixed effects
if(!is.null(RandomEffect)){
  FixedEffectData = Data %>% 
  dplyr::select(c(setdiff(colnames(Data), RandomEffect))) %>% 
  dplyr::select(-1) #Removing the response variable
  
    
  #Removing the response variable
} else {
  FixedEffectData = Data %>% 
  dplyr::select(-1)  #Removing the response variable
  
  }
  
if(Family == "binomial" | Family == "poisson"){
  FixedEffectData = FixedEffectData %>% 
    dplyr::select(-observationID)
  }
  
  if(Family == "binomial"){
    FixedEffectData = FixedEffectData %>% 
      dplyr::select(-1)} # Removing the 'trials' variable

## Specific for covariates with of character class 
suppressWarnings({  
  CharactersFE = FixedEffectData%>%
  dplyr::select(-dplyr::one_of(FixedEffect)) 
  })
  
  if(ncol(CharactersFE) == 0){
    
  } else{
  
for(i in colnames(CharactersFE)){
unique_values = unique(CharactersFE[[i]])

for (j in unique_values) {

  CharactersFE = CharactersFE %>% 
    dplyr::mutate(!!paste(j) := dplyr::if_else(CharactersFE[[i]] == j, 1,0)) %>% 
    dplyr::rename(!!paste0(i, j) := paste(j)) 
  
}
CharactersFE = CharactersFE 
}

FixedEffectData = dplyr::bind_cols(FixedEffectData,CharactersFE) %>% 
  dplyr::select_if(~ is.numeric(.))
}

## Calculate estimated variances for each fixed effect
for (i in colnames(FixedEffectData)){
  if (i %in% colnames(PS)) {
  
    PS[[paste0("var_", i)]] = 0
        
    for (j in 1:length(PS[[paste0("var_", i)]])){
      PS[[paste0("var_", i)]][j] = var(PS[[i]][j] * FixedEffectData[[i]]) 
  }
  }
}

## Calculate total variance in fixed effects
  
# Total variance in fixed effects
FixedEffectNames = intersect(names(PS), paste0("var_", names(FixedEffectData)))

PS = PS %>% 
dplyr::mutate(var_FixedEffects = rowSums(dplyr::across(tidyselect::all_of(FixedEffectNames)), na.rm = TRUE))
    
  
# Calculate the estimated variances in random slope

if(!is.null(RandomSlope)){
  
  
  PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect, "_", RandomSlope) := (get(paste0(RandomEffect, "_", RandomSlope))^2 *
                  var(FixedEffectData[[RandomSlope]])) +
                
                 (get(paste0(RandomEffect,"_", RandomSlope))^2 *
                  mean(FixedEffectData[[RandomSlope]])^2))
  }


           
# Variances in random effect
if(!is.null(RandomEffect)){
  
  # for models without random slopes
  if(is.null(RandomSlope)){ 
PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect) := 
     
                             get(paste0(RandomEffect))^2)
                } else {
  
        
        # for models with random slope (in Holger's paper on random slopes)
                 PS = PS %>% 
  dplyr::mutate(!!paste0("var_", RandomEffect) := 
                  (get(paste0(RandomEffect))^2) +
                  
              (get(paste0("var_", RandomEffect, "_", RandomSlope))) +
                        
                (get(paste0("cor_", RandomEffect, "_",
                            RandomSlope))) *
                   get(paste0(RandomEffect)) *
                   get(paste0(RandomEffect,"_", RandomSlope)) *
                   2 *  mean(FixedEffectData[[RandomSlope]]))
                }
}

                            
# Residual variance
if(Family == "gaussian"){
PS = PS %>% 
  dplyr::mutate(residual = sigma^2)

} else {
  if(Family == "binomial"){

    PS = PS %>% 
      dplyr::mutate(residual = observationID^2 + (pi^2/3))

    } else {
     if(Family== "poisson") {
       
      PS = PS %>% 
        dplyr::mutate(residual =  observationID^2 + 
                                    log(1/exp(Intercept)+1))
     
     } else {
       
       stop("`The family of this model is not yet supported by var_decomp function")
    
       
  }
  }
  }

# Total phenotypic variance
if(!is.null(RandomEffect)){
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           get(paste0("var_", RandomEffect)) + 
           residual) 

} else {
PS = PS %>% 
    dplyr::mutate(total_pv = var_FixedEffects + 
           residual)   
}


# calculate R2 for fixed effects

for (i in FixedEffectNames){
        PS = PS %>% 
           dplyr::mutate(!!paste0("R2_", i) := get(paste0(i))/total_pv)
}

PS = PS %>% 
  dplyr::rename_with(~ stringr::str_replace(., "_var_", "_")) %>% 
  dplyr::mutate(R2_sum_fixed_effects = var_FixedEffects/ total_pv) 
                
      
# calculate R2 for random slopes
    if(!is.null(RandomSlope)){
      
      PS = PS %>%
        dplyr::mutate(!!paste0("R2_", RandomEffect, "_", RandomSlope) := 
                   get(paste0("var_", RandomEffect, "_", RandomSlope))/total_pv)
      } 
  

# calculate R2 for random effect
if(!is.null(RandomEffect)){
PS = PS %>% 
  dplyr::mutate(!!paste0("R2_",RandomEffect) := 
             get(paste0("var_", RandomEffect))/total_pv) 
}
# Residual
PS = PS %>% 
  dplyr::mutate(R2_residual = 
             residual/total_pv)


output = PS %>% 
  dplyr::select(-tidyselect::all_of(RandomEffect)) %>% 
  dplyr::select(-dplyr::starts_with("var_")) %>% 
  dplyr::select(-total_pv) %>% 
  dplyr::select(-residual)

if(Family == "binomial" | Family == "poisson"){
  output = output %>% 
  select(-observationID)
  
}


EstSummary = posterior::summarise_draws(output) %>% 
  dplyr::select(variable, mean, median, sd) 
  
  
#Highest probability density interval
HPDInt = as.data.frame(coda::HPDinterval(mcmcr::as.mcmc(output, combine_chains = TRUE))) %>% 
  tibble::rownames_to_column(var = "variable")

  EstSummary = dplyr::left_join(EstSummary, HPDInt, by = "variable") %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), round, 3)) %>% 
  dplyr::rename(lower_HPD = lower, upper_HPD = upper) 


return(EstSummary)   

}

